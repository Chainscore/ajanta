"""Test for token.pvm generated by jam-sdk-py"""
import os
import logging
import sys
from unittest.mock import MagicMock
from tsrkit_types import Bytes, Uint
from playground.execution.invocations.refine import PsiR
from playground.types.work.package import WorkPackage, Authorizer, WorkItems
from playground.types.work.item import WorkItem, ImportSpecs, ExtrinsicSpecs
from playground.types.protocol.core import ServiceId, Gas, Balance, TimeSlot
from playground.types.protocol.crypto import OpaqueHash
from playground.types.state.state import state
from playground.types.state.delta import AccountData, AccountMetadata
from playground.types.work.report import RefineContext

# Configure logging
root = logging.getLogger()
root.setLevel(logging.DEBUG)
for h in root.handlers[:]:
    root.removeHandler(h)
handler = logging.StreamHandler(sys.stdout)
handler.setLevel(logging.DEBUG)
formatter = logging.Formatter('%(levelname)s: %(message)s')
handler.setFormatter(formatter)
root.addHandler(handler)

jam_logger = logging.getLogger("jam")
jam_logger.setLevel(logging.DEBUG)
pvm_logger = logging.getLogger("pvm")
pvm_logger.setLevel(logging.DEBUG)

# Setup
state.delta.clear()
# Point to the token.pvm built by jam-sdk-py
code_path = "/Users/prasad/projects/tsr/sdk/jam-sdk-py/token.pvm"
if not os.path.exists(code_path):
    raise FileNotFoundError(f"PVM file not found at {code_path}")

code = open(code_path, 'rb').read()
sid = ServiceId(0)
meta = AccountMetadata(
    code_hash=Bytes[32](32), balance=Balance(10**12), gratis_offset=Balance(100),
    gas_limit=Gas(0), min_gas=Gas(0), created_at=TimeSlot(0), accumulated_at=TimeSlot(0),
    parent_service=ServiceId(1), num_i=Uint[32](0), num_o=Uint[64](0)
)
acc = AccountData(service=meta)
acc.historical_lookup = MagicMock(return_value=Bytes(code))
state.delta[sid] = acc

def run(payload):
    wi = WorkItem(service=sid, code_hash=OpaqueHash(bytes(32)), refine_gas_limit=Gas(10000000),
                  accumulate_gas_limit=Gas(10000000), export_count=Uint(0), payload=Bytes(payload),
                  import_segments=ImportSpecs([]), extrinsic=ExtrinsicSpecs([]))
    wp = WorkPackage(auth_code_host=ServiceId(0), authorization=Bytes(b''),
                     authorizer=Authorizer(code_hash=OpaqueHash(bytes(32)), params=Bytes(b'')),
                     context=RefineContext.empty(), items=WorkItems([wi]))
    psir = PsiR(item_index=0, p=wp, auth_trace=b'', i_segments=[], e_offset=0)
    res, _, _ = psir.execute()
    return bytes(res._value)

def to_int(b):
    return int.from_bytes(b[:8], 'little') if len(b) >= 8 else b.hex()

def test_jam_sdk_token():
    print('=== JAM SDK Token Test ===')
    
    # 1. Init
    # CMD 6 = Init owner
    print(f'Init: {run(bytes([0x06])).hex()}')
    
    # 2. Mint 1000 to User 1
    # MINT = 0x01, to=1, amount=1000
    payload = bytes([0x01]) + (1).to_bytes(8, 'little') + (1000).to_bytes(8, 'little')
    print(f'Mint 1000 to User 1: {run(payload).hex()}')
    
    # 3. Check Balance of User 1
    # BALANCE_OF = 0x03, who=1
    payload = bytes([0x03]) + (1).to_bytes(8, 'little')
    print(f'Balance of User 1: {to_int(run(payload))}')
    
    # 4. Transfer 200 from User 100 (hardcoded sender) to User 2
    # Mint 500 to User 100 first
    payload = bytes([0x01]) + (100).to_bytes(8, 'little') + (500).to_bytes(8, 'little')
    print(f'Mint 500 to User 100: {run(payload).hex()}')
    
    # Transfer 200 from User 100 to User 2
    # TRANSFER = 0x02, to=2, amount=200
    payload = bytes([0x02]) + (2).to_bytes(8, 'little') + (200).to_bytes(8, 'little')
    print(f'Transfer 200 from 100 to 2: {run(payload).hex()}')
    
    # 5. Check Balances
    print(f'Balance of User 100: {to_int(run(bytes([0x03]) + (100).to_bytes(8, "little")))}')
    print(f'Balance of User 2: {to_int(run(bytes([0x03]) + (2).to_bytes(8, "little")))}')
    
    # 6. Check User Info for User 2
    # GET_USER = 0x04, who=2
    res = run(bytes([0x04]) + (2).to_bytes(8, 'little'))
    # UserInfo struct: joined_at(8), tx_count(8), is_blocked(4 or 8? C int is usually 4, but alignment might make it 8)
    # In C: typedef struct { uint64_t joined_at; uint64_t tx_count; int is_blocked; } UserInfo;
    # Alignment of uint64_t is 8.
    # Offset 0: joined_at (8 bytes)
    # Offset 8: tx_count (8 bytes)
    # Offset 16: is_blocked (4 bytes)
    # Size is likely 24 bytes (padded to 8 byte boundary)
    
    if len(res) >= 17:
        joined = int.from_bytes(res[:8], 'little')
        tx_count = int.from_bytes(res[8:16], 'little')
        # is_blocked is at offset 16. It's an int (4 bytes).
        blocked = int.from_bytes(res[16:20], 'little')
        print(f'User 2 Info: joined={joined}, tx_count={tx_count}, blocked={blocked}')
    else:
        print(f'User 2 Info Error: {res.hex()}')
        
    # 7. Block User 2
    # BLOCK_USER = 0x05, who=2
    print(f'Block User 2: {run(bytes([0x05]) + (2).to_bytes(8, "little")).hex()}')
    
    # 8. Verify Blocked
    res = run(bytes([0x04]) + (2).to_bytes(8, 'little'))
    blocked = int.from_bytes(res[16:20], 'little')
    print(f'User 2 Blocked Status: {blocked}')
